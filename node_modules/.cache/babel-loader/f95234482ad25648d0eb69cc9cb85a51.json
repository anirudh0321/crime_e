{"ast":null,"code":"var sha3 = require(\"crypto-js/sha3\");\n\nvar schema_version = require(\"./package.json\").version;\n\nvar TruffleSchema = {\n  // Normalize options passed in to be the exact options required\n  // for truffle-contract.\n  //\n  // options can be three things:\n  // - normal object\n  // - contract object\n  // - solc output\n  //\n  // TODO: Is extra_options still necessary?\n  normalizeOptions: function normalizeOptions(options, extra_options) {\n    extra_options = extra_options || {};\n    var normalized = {};\n    var expected_keys = [\"contract_name\", \"abi\", \"binary\", \"unlinked_binary\", \"address\", \"networks\", \"links\", \"events\", \"network_id\", \"default_network\", \"updated_at\"]; // Merge options/contract object first, then extra_options\n\n    expected_keys.forEach(function (key) {\n      var value;\n\n      try {\n        // Will throw an error if key == address and address doesn't exist.\n        value = options[key];\n\n        if (value != undefined) {\n          normalized[key] = value;\n        }\n      } catch (e) {// Do nothing.\n      }\n\n      try {\n        // Will throw an error if key == address and address doesn't exist.\n        value = extra_options[key];\n\n        if (value != undefined) {\n          normalized[key] = value;\n        }\n      } catch (e) {// Do nothing.\n      }\n    }); // Now look for solc specific items.\n\n    if (options.interface != null) {\n      normalized.abi = JSON.parse(options.interface);\n    }\n\n    if (options.bytecode != null) {\n      normalized.unlinked_binary = options.bytecode;\n    } // Assume any binary passed is the unlinked binary\n\n\n    if (normalized.unlinked_binary == null && normalized.binary) {\n      normalized.unlinked_binary = normalized.binary;\n    }\n\n    delete normalized.binary;\n    this.copyCustomOptions(options, normalized);\n    return normalized;\n  },\n  // Generate a proper binary from normalized options, and optionally\n  // merge it with an existing binary.\n  generateBinary: function generateBinary(options, existing_binary, extra_options) {\n    extra_options = extra_options || {};\n    existing_binary = existing_binary || {};\n\n    if (options.overwrite == true) {\n      existing_binary = {};\n    }\n\n    existing_binary.contract_name = options.contract_name || existing_binary.contract_name || \"Contract\";\n    existing_binary.default_network = options.default_network || existing_binary.default_network;\n    existing_binary.abi = options.abi || existing_binary.abi;\n    existing_binary.unlinked_binary = options.unlinked_binary || existing_binary.unlinked_binary; // Ensure unlinked binary starts with a 0x\n\n    if (existing_binary.unlinked_binary && existing_binary.unlinked_binary.indexOf(\"0x\") < 0) {\n      existing_binary.unlinked_binary = \"0x\" + existing_binary.unlinked_binary;\n    } // Merge existing networks with any passed in networks.\n\n\n    existing_binary.networks = existing_binary.networks || {};\n    options.networks = options.networks || {};\n    Object.keys(options.networks).forEach(function (network_id) {\n      existing_binary.networks[network_id] = options.networks[network_id];\n    });\n    var updated_at = new Date().getTime();\n\n    if (options.network_id) {\n      // Ensure an object exists for this network.\n      existing_binary.networks[options.network_id] = existing_binary.networks[options.network_id] || {};\n      var network = existing_binary.networks[options.network_id]; // Override specific keys\n\n      network.address = options.address || network.address;\n      network.links = options.links; // merge events with any that previously existed\n\n      network.events = network.events || {};\n      options.events = options.events || {};\n      Object.keys(options.events).forEach(function (event_id) {\n        options.events[event_id] = options.events[event_id];\n      }); // Now overwrite any events with the most recent data from the ABI.\n\n      existing_binary.abi.forEach(function (item) {\n        if (item.type != \"event\") return;\n        var signature = item.name + \"(\" + item.inputs.map(function (param) {\n          return param.type;\n        }).join(\",\") + \")\";\n        network.events[\"0x\" + sha3(signature, {\n          outputLength: 256\n        })] = item;\n      });\n\n      if (extra_options.dirty !== false) {\n        network.updated_at = updated_at;\n      }\n    } else {\n      if (options.address) {\n        throw new Error(\"Cannot set address without network id\");\n      }\n    } // Ensure all networks have a `links` object.\n\n\n    Object.keys(existing_binary.networks).forEach(function (network_id) {\n      var network = existing_binary.networks[network_id];\n      network.links = network.links || {};\n    });\n    existing_binary.schema_version = schema_version;\n\n    if (extra_options.dirty !== false) {\n      existing_binary.updated_at = updated_at;\n    } else {\n      existing_binary.updated_at = options.updated_at || existing_binary.updated_at || updated_at;\n    }\n\n    this.copyCustomOptions(options, existing_binary);\n    return existing_binary;\n  },\n  copyCustomOptions: function copyCustomOptions(from, to) {\n    // Now let all x- options through.\n    Object.keys(from).forEach(function (key) {\n      if (key.indexOf(\"x-\") != 0) return;\n\n      try {\n        value = from[key];\n\n        if (value != undefined) {\n          to[key] = value;\n        }\n      } catch (e) {// Do nothing.\n      }\n    });\n  }\n};\nmodule.exports = TruffleSchema;","map":null,"metadata":{},"sourceType":"script"}